# Gmailクォーター制限エラー対応の設計仕様書
## 1. 目的

- Gmail に届くメール（新規・スレッド返信）を 5分間隔で自動取得
- 転送元ドメインに応じて スプレッドシートのシート別に整理・出力
- 取りこぼし・重複出力を完全に防止
- 一般 Google アカウントの Gmail クォータ制限内で安定稼働させる


## 2. 前提条件

| 項目 | 内容 |
|------|------|
| Gmail アカウント | 一般 Google アカウント（Workspace ではない） |
| トリガー | 5分間隔（変更不可） |
| 実行環境 | Google Apps Script |
| 出力先 | Google スプレッドシート |
| 現在のシート | 「電気・ガス」「インターネット関連」 |
| メール量（ピーク） | 最大 10〜11件 / 5分 |


## 3. 全体アーキテクチャ概要

```
Gmail
 └─ スレッド検索（時刻差分）
     └─ スレッド内メッセージ走査
         ├─ 短期履歴チェック（Properties）
         ├─ 永続履歴チェック（Sheet）
         └─ バッファリング
             └─ シートへ一括書き込み
```


## 4. Gmail 取得設計（取りこぼし防止）

### 4.1 検索基準

**基準プロパティ：** `LAST_PROCESSED_THREAD_TIME`（ミリ秒）

**検索条件：**
```
in:inbox after:(LAST_PROCESSED_THREAD_TIME - 10分)
```

**安全マージン（10分）を設ける理由：**
- Gmail インデックス遅延
- トリガー実行の時間ズレ
- 月末・月初・年末年始の境界

> 💡 時刻ベースで完全吸収する設計

### 4.2 取得スレッド数

**最大 11 スレッド**

**設計理由：**
- ピーク時想定：最大 10〜11件 / 5分
- クォータ消費を抑えつつ、取りこぼしを防ぐ安全側設定
- 10 → 11 への増加は クォータ的に誤差レベル

### 4.3 スレッド内メッセージの扱い

- 最新 → 過去 の逆順で走査
- 処理済みメッセージIDに到達した時点で 即打ち切り

> 💡 無駄な過去メッセージ走査を防止


## 5. 重複防止設計（最重要）

### なぜ多層構造が必要か

- `MESSAGE_ID_HISTORY` は永続ストレージではない
- 過去に「日次リセット仕様」が存在
- スレッドには 数日前のメッセージが混在する可能性がある

> 💡 単一防衛では必ず破綻する


## 6. 重複防止の三層構造

### 第1層：短期履歴（高速・一次防衛）

**`MESSAGE_ID_HISTORY`（PropertiesService）**

- **内容：** 最近処理した messageId
- **上限：** 5000件
- **役割：**
  - 同一実行内・短期間での再処理防止
  - Gmail API 呼び出し削減

> ⚠️ 消失しても致命傷にならない設計

### 第2層：取得範囲制御

**`LAST_PROCESSED_THREAD_TIME`**

- **内容：** 最後に確認したスレッドの最終更新時刻
- **役割：**
  - Gmail 検索範囲の制御
  - 不要なスレッド展開の抑制

### 第3層：永続重複防止（最終防衛）

**シート上の「メッセージID列」**

- シートごとに 既存 msgId を事前ロード
- `existingMsgIdSetBySheet` として Set 化
- メッセージ処理時に 即スキップ判定

> **判定基準：** 「この messageId は、このシートに既に存在するか？」
> 
> 💡 YES の場合は絶対に再出力しない


## 7. 初期ロード設計（最適化済み）

**シート初期ロード**

- `domainToSheetMap` から シート名を一意化
- 各シートにつき 初期ロードは1回のみ

```javascript
const uniqueSheetNames = [...new Set(Object.values(domainToSheetMap))];
```

**効果：**
- ログの重複出力防止
- 無駄な `getRange()` 呼び出し削減
- 将来シート追加時も安全


## 8. 初期化戦略

**`LAST_PROCESSED_THREAD_TIME` 初期値：** 現在時刻 − 10分

**理由：**
- 初回実行での全件取得を防止
- 直前のメールは確実に拾う
- クォータ消費を最小化


## 9. シート構造設計

**ヘッダー構成：**

```javascript
const GAS_HEADERS = ["送信日時","送信者","件名","本文","添付の有無","スレッドID","メッセージID"];
const INITIAL_HEADERS = ["対応確認","備考","対応者", ...GAS_HEADERS];
```

- 手動入力列と自動生成列を明確に分離
- GAS 自動生成列は 編集不可（保護）

## 10. バッチ書き込み設計

- シートごとにメモリ上でバッファリング
- `insertRowsBefore` + `setValues` による 一括書き込み
- パフォーマンス・クォータ両面で最適


## 11. クォータ耐性評価

### ピーク時想定（最大）

- 11件 / 5分
- 約 300 実行 / 日

### Gmail API 呼び出し

- `search`：1回 / 実行
- `getMessages`：最大11スレッド分

> 💡 一般アカウントの制限内で十分余裕あり


## 12. 本設計で保証されること

✅ スレッドに古いメッセージが混在しても重複しない  
✅ `MESSAGE_ID_HISTORY` が消失しても重複しない  
✅ 月末・年末年始でも取りこぼしなし  
✅ 手動再実行・障害復旧後も安全  
✅ シートが存在する限り msgId の一意性が保証される

## 13. 変更・反映手順

### 必要な作業

- `saveGmailToSheetBySenderWithDomainFilter` 関数を 最終版に差し替え

### 不要な作業

- Properties のリセット
- シートの整理
- トリガー設定変更
- 既存データの削除


## 14. 設計上の結論

本設計は、

- 短期記憶（Properties）
- 時刻差分（Thread Time）
- 永続真実（Sheet）

を組み合わせた **実運用に耐える・破綻しない設計** である。